$date
	Fri Jul 21 19:52:48 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module combined_tb $end
$var wire 1 ! overflow $end
$var wire 1 " zero $end
$var wire 32 # writedata [31:0] $end
$var wire 1 $ regwrite $end
$var wire 32 % readdata [31:0] $end
$var wire 32 & mux_out [31:0] $end
$var wire 1 ' memwrite $end
$var wire 1 ( memtoreg $end
$var wire 1 ) memread $end
$var wire 32 * instruction [31:0] $end
$var wire 32 + immediate [31:0] $end
$var wire 1 , branch $end
$var wire 32 - b [31:0] $end
$var wire 1 . alusrc $end
$var wire 2 / aluop [1:0] $end
$var wire 4 0 aluctl [3:0] $end
$var wire 32 1 alu_out [31:0] $end
$var wire 32 2 a [31:0] $end
$var reg 1 3 clk $end
$var reg 10 4 pc [9:0] $end
$var reg 2 5 state [1:0] $end
$var integer 32 6 i [31:0] $end
$scope module uutA $end
$var wire 1 3 clk $end
$var wire 10 7 pc [9:0] $end
$var reg 32 8 instruction [31:0] $end
$upscope $end
$scope module uutB $end
$var wire 1 3 clk $end
$var wire 7 9 instruction [6:0] $end
$var reg 2 : aluop [1:0] $end
$var reg 1 . alusrc $end
$var reg 1 , branch $end
$var reg 1 ) memread $end
$var reg 1 ( memtoreg $end
$var reg 1 ' memwrite $end
$var reg 1 $ regwrite $end
$upscope $end
$scope module uutC $end
$var wire 2 ; aluop [1:0] $end
$var wire 3 < func3 [2:0] $end
$var wire 7 = func7 [6:0] $end
$var reg 4 > aluctl [3:0] $end
$upscope $end
$scope module uutD $end
$var wire 32 ? instruction [31:0] $end
$var reg 32 @ result [31:0] $end
$upscope $end
$scope module uutE $end
$var wire 32 A in2 [31:0] $end
$var wire 1 . s $end
$var wire 32 B in1 [31:0] $end
$var reg 32 C out [31:0] $end
$upscope $end
$scope module uutF $end
$var wire 1 3 clk $end
$var wire 5 D rd [4:0] $end
$var wire 1 $ regwrite $end
$var wire 5 E rs1 [4:0] $end
$var wire 5 F rs2 [4:0] $end
$var wire 32 G writedata [31:0] $end
$var reg 32 H readdata1 [31:0] $end
$var reg 32 I readdata2 [31:0] $end
$upscope $end
$scope module uutG $end
$var wire 32 J a [31:0] $end
$var wire 4 K aluctl [3:0] $end
$var wire 32 L b [31:0] $end
$var wire 1 ! overflow $end
$var wire 1 " zero $end
$var reg 32 M out [31:0] $end
$upscope $end
$scope module uutH $end
$var wire 10 N address [9:0] $end
$var wire 1 3 clk $end
$var wire 1 ) memread $end
$var wire 1 ' memwrite $end
$var wire 32 O writedata [31:0] $end
$var reg 32 P readdata [31:0] $end
$upscope $end
$scope module uutI $end
$var wire 32 Q in1 [31:0] $end
$var wire 32 R in2 [31:0] $end
$var wire 1 ( s $end
$var reg 32 S out [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
b1111111111 7
b101100 6
b0 5
b1111111111 4
03
bx 2
bx 1
bx 0
bx /
x.
bx -
x,
bx +
bx *
x)
x(
x'
bx &
bx %
x$
bx #
x"
z!
$end
#1
b1 +
b1 @
b1 A
b10 0
b10 >
b10 K
b0 <
b0 =
b1010 D
b1 F
b0 E
b10011 9
b100000000010100010011 *
b100000000010100010011 8
b100000000010100010011 ?
b0 /
b0 :
b0 ;
0,
0(
0'
0)
0$
0.
b1 5
b0 4
b0 7
13
#2
03
#3
b1 #
b1 G
b1 S
b1 N
0"
b1 1
b1 M
b1 Q
b1 &
b1 C
b1 L
b0 2
b0 H
b0 J
1$
1.
b10 5
13
#4
03
#5
b0 5
13
#6
03
#7
b1 5
b1 4
b1 7
13
#8
03
#9
b1011 D
b1010 E
b101010000010110010011 *
b101010000010110010011 8
b101010000010110010011 ?
b10 5
13
#10
03
#11
b10 #
b10 G
b10 S
b10 N
b10 1
b10 M
b10 Q
b1 2
b1 H
b1 J
b0 5
13
#12
03
#13
b11 #
b11 G
b11 S
b11 N
b11 1
b11 M
b11 Q
b10 &
b10 C
b10 L
b10 +
b10 @
b10 A
b1100 D
b10 F
b1001010000011000010011 *
b1001010000011000010011 8
b1001010000011000010011 ?
b1 5
b10 4
b10 7
13
#14
03
#15
b10 5
13
#16
03
#17
b0 5
13
#18
03
#19
b1 5
b11 4
b11 7
13
#20
03
#21
b1 #
b1 G
b1 S
b1 N
b1 1
b1 M
b1 Q
b0 &
b0 C
b0 L
b0 +
b0 @
b0 A
b0 D
b0 F
b0 E
b0 9
b0 *
b0 8
b0 ?
b10 5
13
#22
03
#23
b0 #
b0 G
b0 S
b0 N
1"
b0 1
b0 M
b0 Q
b0 -
b0 B
b0 I
b0 O
b0 2
b0 H
b0 J
0$
0.
b0 5
13
#24
03
#25
b1001 +
b1001 @
b1001 A
b10 <
b1001 D
b1010 F
b100011 9
b101000000010010010100011 *
b101000000010010010100011 8
b101000000010010010100011 ?
b1 5
b100 4
b100 7
13
#26
03
#27
b1001 #
b1001 G
b1001 S
b1001 N
0"
b1001 1
b1001 M
b1001 Q
b1001 &
b1001 C
b1001 L
b1 -
b1 B
b1 I
b1 O
1'
1.
b10 5
13
#28
03
#29
b0 5
13
#30
03
#31
b1 5
b101 4
b101 7
13
#32
03
#33
b0 #
b0 G
b0 S
b0 N
1"
b0 1
b0 M
b0 Q
b0 &
b0 C
b0 L
b0 +
b0 @
b0 A
b0 <
b0 D
b0 F
b0 9
b0 *
b0 8
b0 ?
b10 5
13
#34
03
#35
b0 -
b0 B
b0 I
b0 O
0'
0.
b0 5
13
#36
03
#37
b11 +
b11 @
b11 A
b1101 D
b11 F
b1010 E
b10011 9
b1101010000011010010011 *
b1101010000011010010011 8
b1101010000011010010011 ?
b1 5
b110 4
b110 7
13
#38
03
#39
b100 #
b100 G
b100 S
b100 N
0"
b100 1
b100 M
b100 Q
b11 &
b11 C
b11 L
bx -
bx B
bx I
bx O
b1 2
b1 H
b1 J
1$
1.
b10 5
13
#40
03
#41
b0 5
13
#42
03
#43
b1 5
b111 4
b111 7
13
#44
03
#45
b1 #
b1 G
b1 S
b1 N
b1 1
b1 M
b1 Q
b0 &
b0 C
b0 L
b0 +
b0 @
b0 A
b1110 D
b1011 F
b1101 E
b110011 9
b101101101000011100110011 *
b101101101000011100110011 8
b101101101000011100110011 ?
b10 5
13
#46
03
#47
b110 #
b110 G
b110 S
b110 N
b110 1
b110 M
b110 Q
b10 &
b10 C
b10 L
b10 -
b10 B
b10 I
b10 O
b100 2
b100 H
b100 J
b10 /
b10 :
b10 ;
0.
b0 5
13
#48
03
#49
b1111 D
b0 F
b1110 E
b10011 9
b1110000011110010011 *
b1110000011110010011 8
b1110000011110010011 ?
b1 5
b1000 4
b1000 7
13
#50
03
